<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=Windows-1251">
<title>NL: Файл svd.h</title>
<link href="nl.doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Создано системой Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Титульная&nbsp;страница</span></a></li>
    <li><a href="classes.html"><span>Классы</span></a></li>
    <li id="current"><a href="files.html"><span>Файлы</span></a></li>
    <li><a href="pages.html"><span>Описания</span></a></li>
    <li><a href="examples.html"><span>Примеры</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;Поиск&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>Файлы</span></a></li>
    <li><a href="globals.html"><span>Список&nbsp;членов&nbsp;всех&nbsp;файлов</span></a></li>
  </ul></div>
<h1>Файл svd.h</h1>Сингулярное разложение. <a href="#_details">Подробнее...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Функции</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a> (double **A, size_t m, size_t n, double *w, int matu, double **U, int matv, double **V, size_t *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Сингулярное разложение матрицы.  <a href="#25912e790664b081154c198409852b60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svd_8h.html#b87f7024824d423cf528e828d2123c3a">svd_correct</a> (double *w, size_t n, double rel_err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Автоматическое корректирование вычисленных сингулярных чисел.  <a href="#b87f7024824d423cf528e828d2123c3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svd_8h.html#a5369f18acc0bf08d3c0815729e125b5">svd_cond</a> (double *w, size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Вычисление спектрального числа обусловленности на основе сингулярного разложения.  <a href="#a5369f18acc0bf08d3c0815729e125b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="svd_8h.html#645443f1647b1204210c9835f15aa5fc">svd_least_squares</a> (double **U, double *w, double **V, size_t m, size_t n, double *b, double *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Нахождение нормального псевдорешения системы линейных уравнений на основе сингулярного разложения.  <a href="#645443f1647b1204210c9835f15aa5fc"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Подробное описание</h2>
Сингулярное разложение. 
<p>
Файл содержит функции, строящие и использующие сингулярное разложение матрицы.<p>
Cингулярным разложением прямоугольной матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> размера <img class="formulaInl" alt="$m\times n$" src="form_10.png">, <img class="formulaInl" alt="$m \ge n$" src="form_377.png"> называется ее представление <img class="formulaInl" alt="$A = U S V^{\rm T}$" src="form_406.png">, где<ul>
<li><img class="formulaInl" alt="$U$" src="form_134.png"> - матрица размера <img class="formulaInl" alt="$m \times n$" src="form_33.png"> с ортонормированными столбцами,</li><li><img class="formulaInl" alt="$V$" src="form_379.png"> - ортогональная матрица размера <img class="formulaInl" alt="$n \times n$" src="form_380.png">,</li><li><img class="formulaInl" alt="$S$" src="form_381.png"> - диагональная <img class="formulaInl" alt="$n \times n$" src="form_380.png"> матрица с неотрицательными диагональными элементами, называемыми сингулярными числами.</li></ul>
<p>
Отношение максимального сингулярного числа к минимальному есть спектральное число обусловленности квадратной матрицы. Число <img class="formulaInl" alt="$r$" src="form_42.png"> ненулевых сингулярных чисел указывает ранг матрицы. При вычислениях на компьютере вместо нулевых сингулярных чисел могут быть получены ненулевые, поэтому вычисленные сингулярные числа необходимо отредактировать с учетом погрешности вычислений.<p>
Сингулярное разложение используется для нахождения нормального псевдорешения прямоугольной системы <img class="formulaInl" alt="$Ax = b$" src="form_382.png">. Вектор x называется псевдорешением системы <img class="formulaInl" alt="$Ax=b$" src="form_2.png">, если на нем достигается минимум <img class="formulaInl" alt="$\|Ax-b\|_2$" src="form_69.png">. Псевдорешение <img class="formulaInl" alt="$x$" src="form_40.png"> называется нормальным, если среди всех псевдорешений оно имеет минимальную длину. Для любой системы нормальное псевдорешение единственно.<p>
Пусть <img class="formulaInl" alt="$S={\rm diag}(\sigma_1,\dots,\sigma_r,0,\dots,0)$" src="form_383.png">, <img class="formulaInl" alt="$U=(U_1, U_2)$" src="form_384.png">, <img class="formulaInl" alt="$V=(V_1, V_2)$" src="form_385.png">, где <img class="formulaInl" alt="$U_1$" src="form_386.png">, <img class="formulaInl" alt="$V_1$" src="form_387.png"> имеют по <img class="formulaInl" alt="$r$" src="form_42.png"> столбцов каждая. Нормальное псевдорешение можно найти по формуле <img class="formulaInl" alt="$x = V_1 S_1^{-1} U_1^{\rm T} b$" src="form_388.png">. <hr><h2>Функции</h2>
<a class="anchor" name="a5369f18acc0bf08d3c0815729e125b5"></a><!-- doxytag: member="svd.h::svd_cond" ref="a5369f18acc0bf08d3c0815729e125b5" args="(double *w, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double svd_cond           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Вычисление спектрального числа обусловленности на основе сингулярного разложения. 
<p>
Функция вычисляет спектральное число обусловленности матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> на основе найденного функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a> сингулярного разложения <img class="formulaInl" alt="$A = USV^{\rm T}$" src="form_404.png">. Матрица A имеет размеры <img class="formulaInl" alt="$m\times n$" src="form_10.png">, <img class="formulaInl" alt="$m \ge n$" src="form_377.png">. Спектральное число обусловленности равно отношению максимального сингулярного значения к минимальному.<p>
<ul>
<li>Вход:<ul>
<li><img class="formulaInl" alt="$w$" src="form_391.png"> - вектор длины <img class="formulaInl" alt="$n$" src="form_37.png">, возвращаемый функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a> и содержащий сингулярные числа матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li><li><img class="formulaInl" alt="$n$" src="form_37.png"> - число столбцов матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li></ul>
</li></ul>
<p>
<ul>
<li>Выход: функция возвращает спектральное число обусловленности</li></ul>
<p>
Трудоемкость: 
</div>
</div><p>
<a class="anchor" name="b87f7024824d423cf528e828d2123c3a"></a><!-- doxytag: member="svd.h::svd_correct" ref="b87f7024824d423cf528e828d2123c3a" args="(double *w, size_t n, double rel_err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svd_correct           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rel_err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Автоматическое корректирование вычисленных сингулярных чисел. 
<p>
Функция зануляет близкие к нулю сингулярные числа матрицы <img class="formulaInl" alt="$A$" src="form_767.png">, вычисленные функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>, с учетом задаваемой относительной погрешности <img class="formulaInl" alt="$rel\_err$" src="form_398.png">. Матрица A имеет размеры <img class="formulaInl" alt="$m\times n$" src="form_10.png">, <img class="formulaInl" alt="$m \ge n$" src="form_377.png">. Величина <img class="formulaInl" alt="$rel\_err$" src="form_398.png"> должна отражать ошибку в исходных данных (в матрице <img class="formulaInl" alt="$A$" src="form_767.png">). Если данные рассматриваются как точные, то необходимо задать <img class="formulaInl" alt="$rel\_err = 0$" src="form_399.png">. В этом случае функция установит значение <img class="formulaInl" alt="$rel\_err$" src="form_398.png">, отражающее ошибку при вычислениях в самой функции <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>, а именно, <img class="formulaInl" alt="$\varepsilon\cdot n$" src="form_400.png">, где <img class="formulaInl" alt="$\varepsilon \approx 10^{16}$" src="form_411.png"> - расстояние между <img class="formulaInl" alt="$1$" src="form_153.png"> и следующим за ним числом в арифметике двойной точности. Зануляются сингулярные значения, не превосходящие <img class="formulaInl" alt="$rell\_err \cdot \sigma_{\max}$" src="form_402.png">, где <img class="formulaInl" alt="$\sigma_{\max}$" src="form_403.png"> - максимальное сингулярное значение.<p>
<ul>
<li>Вход:<ul>
<li><img class="formulaInl" alt="$w$" src="form_391.png"> - вектор длины n, возвращаемый функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>.</li><li><img class="formulaInl" alt="$n$" src="form_37.png"> - число столбцов матрицы A</li><li><img class="formulaInl" alt="$rel\_err$" src="form_398.png"> - относительная погрешность</li></ul>
</li></ul>
<p>
<ul>
<li>Выход:<ul>
<li><img class="formulaInl" alt="$w$" src="form_391.png"> - скорректированные сингулярные числа, вектор длины <img class="formulaInl" alt="$n$" src="form_37.png"> </li></ul>
</li></ul>
<dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xsvd_8c-example.html#a190">xsvd.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="25912e790664b081154c198409852b60"></a><!-- doxytag: member="svd.h::svd_decomp" ref="25912e790664b081154c198409852b60" args="(double **A, size_t m, size_t n, double *w, int matu, double **U, int matv, double **V, size_t *ierr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svd_decomp           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>ierr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Сингулярное разложение матрицы. 
<p>
Функция находит сингулярное разложение <img class="formulaInl" alt="$A = U\cdot S\cdot V^{\rm T}$" src="form_378.png"> вещественной матрицы A размера <img class="formulaInl" alt="$m\times n$" src="form_10.png">, <img class="formulaInl" alt="$m \ge n$" src="form_377.png">.<p>
<ul>
<li>Вход:<ul>
<li><img class="formulaInl" alt="$A$" src="form_767.png"> - прямоугольная матрица размера <img class="formulaInl" alt="$m \times n$" src="form_33.png"></li><li><img class="formulaInl" alt="$m$" src="form_36.png"> - число строк матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li><li><img class="formulaInl" alt="$n$" src="form_37.png"> - число столбцов матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li><li><img class="formulaInl" alt="$matu$" src="form_409.png"> - равно <img class="formulaInl" alt="$1$" src="form_153.png">, если требуется найти матрицу <img class="formulaInl" alt="$U$" src="form_134.png">: равно <img class="formulaInl" alt="$0$" src="form_314.png">, если не требуется</li><li><img class="formulaInl" alt="$matv$" src="form_390.png"> - равно <img class="formulaInl" alt="$1$" src="form_153.png">, если требуется найти матрицу <img class="formulaInl" alt="$V$" src="form_379.png">: равно <img class="formulaInl" alt="$0$" src="form_314.png">, если не требуется</li></ul>
</li></ul>
<p>
<ul>
<li>Выход:<ul>
<li><img class="formulaInl" alt="$A$" src="form_767.png"> - не изменяется</li><li><img class="formulaInl" alt="$w$" src="form_391.png"> - вектор длины n, содержащий сингулярные числа матрицы <img class="formulaInl" alt="$A$" src="form_767.png">. Числа, обычно (но не обязательно), упорядочены по убыванию. В случае ошибки сингулярные числа, стоящие на позициях <img class="formulaInl" alt="$ierr$" src="form_392.png">, <img class="formulaInl" alt="$ierr+1$" src="form_393.png">, <img class="formulaInl" alt="$\dots$" src="form_394.png">, <img class="formulaInl" alt="$n - 1$" src="form_395.png">, правильные.</li><li><img class="formulaInl" alt="$U$" src="form_134.png"> - прямоугольная матрица размера <img class="formulaInl" alt="$m \times n$" src="form_33.png">. В случае ошибки столбцы матрицы <img class="formulaInl" alt="$U$" src="form_134.png">, стоящие на позициях <img class="formulaInl" alt="$ierr$" src="form_392.png">, <img class="formulaInl" alt="$ierr+1$" src="form_393.png">, <img class="formulaInl" alt="$\dots$" src="form_394.png">, <img class="formulaInl" alt="$n - 1$" src="form_395.png">, корректны.</li><li><img class="formulaInl" alt="$V$" src="form_379.png"> - квадратная матрица порядка <img class="formulaInl" alt="$n$" src="form_37.png">. В случае ошибки столбцы матрицы <img class="formulaInl" alt="$V$" src="form_379.png">, стоящие на позициях <img class="formulaInl" alt="$ierr$" src="form_392.png">, <img class="formulaInl" alt="$ierr+1$" src="form_393.png">, <img class="formulaInl" alt="$\dots$" src="form_394.png">, <img class="formulaInl" alt="$n - 1$" src="form_395.png">, корректны.</li><li>ierr устанавливается равным<ul>
<li><img class="formulaInl" alt="$0$" src="form_314.png"> при нормальной работе</li><li><img class="formulaInl" alt="$k$" src="form_333.png">, если <img class="formulaInl" alt="$k$" src="form_333.png">-е сингулярное число не было определено за <img class="formulaInl" alt="$30$" src="form_396.png"> итераций</li></ul>
</li></ul>
</li></ul>
<p>
Алгоритм состоит из двух частей. На первом этапе отражениями Хаусхолдера матрица <img class="formulaInl" alt="$A$" src="form_767.png"> приводится к двухдиагональному виду. На втором этапе вариантом <img class="formulaInl" alt="$QR$" src="form_26.png">-алгоритма двухдиагональная матрица приводится к диагональному виду <img class="formulaInl" alt="$S$" src="form_381.png">.<p>
Функция является переводом фортрановской программы svd из книги [FMM].<p>
Трудоемкость:<p>
Дополнительная память: O(n) <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xsvd_8c-example.html#a187">xsvd.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="645443f1647b1204210c9835f15aa5fc"></a><!-- doxytag: member="svd.h::svd_least_squares" ref="645443f1647b1204210c9835f15aa5fc" args="(double **U, double *w, double **V, size_t m, size_t n, double *b, double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void svd_least_squares           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Нахождение нормального псевдорешения системы линейных уравнений на основе сингулярного разложения. 
<p>
Функция находит нормальное псевдорешение системы линейных уравнений <img class="formulaInl" alt="$Ax = b$" src="form_382.png"> на основе вычисленного функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a> сингулярного разложения <img class="formulaInl" alt="$A = USV^{\rm T}$" src="form_404.png">. Матрица A имеет размеры <img class="formulaInl" alt="$m\times n$" src="form_10.png">, <img class="formulaInl" alt="$m \ge n$" src="form_377.png">. При вычислении псевдорешения используются только ненулевые сингулярные значения. Перед вызовом функции рекомендуется занулить близкие к нулю сингулярные значения (например, с помощью функции <a class="el" href="svd_8h.html#b87f7024824d423cf528e828d2123c3a">svd_correct</a>).<p>
<ul>
<li>Вход:<ul>
<li><img class="formulaInl" alt="$U$" src="form_134.png"> - прямоугольная матрица размера <img class="formulaInl" alt="$m \times n$" src="form_33.png">, возвращаемая функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>.</li><li><img class="formulaInl" alt="$V$" src="form_379.png"> - квадратная матрица порядка <img class="formulaInl" alt="$n$" src="form_37.png">, возвращаемая функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>.</li><li><img class="formulaInl" alt="$w$" src="form_391.png"> - вектор длины <img class="formulaInl" alt="$n$" src="form_37.png">, возвращаемый функцией <a class="el" href="svd_8h.html#25912e790664b081154c198409852b60">svd_decomp</a>.</li><li><img class="formulaInl" alt="$m$" src="form_36.png"> - число строк матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li><li><img class="formulaInl" alt="$n$" src="form_37.png"> - число столбцов матрицы <img class="formulaInl" alt="$A$" src="form_767.png"></li><li><img class="formulaInl" alt="$b$" src="form_41.png"> - правая часть системы <img class="formulaInl" alt="$Ax = b$" src="form_382.png">, вектор длины <img class="formulaInl" alt="$m$" src="form_36.png"></li></ul>
</li></ul>
<p>
<ul>
<li>Выход:<ul>
<li><img class="formulaInl" alt="$x$" src="form_40.png"> - найденное нормальное псевдорешение, вектор длины <img class="formulaInl" alt="$n$" src="form_37.png"></li></ul>
</li></ul>
<p>
Трудоемкость: <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xsvd_8c-example.html#a191">xsvd.c</a>.</dl>
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Документация по NL. Последние изменения: Mon Oct 9 12:25:55 2006. Создано системой&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
