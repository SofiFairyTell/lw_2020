<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=Windows-1251">
<title>NL: Файл eig.h</title>
<link href="nl.doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Создано системой Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Титульная&nbsp;страница</span></a></li>
    <li><a href="classes.html"><span>Классы</span></a></li>
    <li id="current"><a href="files.html"><span>Файлы</span></a></li>
    <li><a href="pages.html"><span>Описания</span></a></li>
    <li><a href="examples.html"><span>Примеры</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;Поиск&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>Файлы</span></a></li>
    <li><a href="globals.html"><span>Список&nbsp;членов&nbsp;всех&nbsp;файлов</span></a></li>
  </ul></div>
<h1>Файл eig.h</h1>Проблема собственных значений. <a href="#_details">Подробнее...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Функции</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#fbf02412f8eab9390ee067b063b1bc0b">eig_tridiag_reduction</a> (double **A, size_t n, int matq, double *d, double *a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Приведение симметричной матрицы к трехдиагональному виду.  <a href="#fbf02412f8eab9390ee067b063b1bc0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#78db68ad25d74fbc89a39523c050e5d8">eig_tridiag</a> (double *d, double *a, size_t n, int matq, double **Q, size_t *rc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Собственные числа симметричной трехдиагональной системы.  <a href="#78db68ad25d74fbc89a39523c050e5d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#2e9fc4e1f537973409ca88b08534a69c">eig_jacobi</a> (double **A, size_t n, double *w, int matq, double **Q, int *nrot, int *rc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Метод Якоби решения симметричной проблемы собственных значений.  <a href="#2e9fc4e1f537973409ca88b08534a69c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#ee133dfdb5a882f517f8fda6ddc6ada9">eig_balance</a> (double **A, size_t n, size_t *low, size_t *high, double *scal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Балансирование вещественной матрицы.  <a href="#ee133dfdb5a882f517f8fda6ddc6ada9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#e2b0a2e73beda2bf908dcf1575fb944a">eig_hess_reduction</a> (double **A, size_t n, size_t low, size_t high, size_t *perm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Приведение матрицы к верхней форме Хессенберга.  <a href="#e2b0a2e73beda2bf908dcf1575fb944a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#a2e230849ca0b84faf88045e6c6ecab9">eig_hess_transform_matrix</a> (double **A, size_t n, size_t low, size_t high, size_t *perm, double **Q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Трансформирующая матрица к верхней форме Хессенберга.  <a href="#a2e230849ca0b84faf88045e6c6ecab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#8b87b34e7fa36007973b13d68cda22b6">eig_hess</a> (double **A, size_t n, size_t low, size_t high, double *wr, double *wi, int matq, double **Q, size_t *iter, size_t *rc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Собственные числа и векторы матрицы Хессенберга.  <a href="#8b87b34e7fa36007973b13d68cda22b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#51d2cf2b45610b86ca6257fd58b3aa08">eig_balance_inverse</a> (double **Q, size_t n, size_t low, size_t high, double *scal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Обратное балансирование.  <a href="#51d2cf2b45610b86ca6257fd58b3aa08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#c97ca0a05188a5c95e6bf0db308ba7ab">eig_norm_Inf</a> (double **Q, size_t n, double *wi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Нормирование собственных векторов.  <a href="#c97ca0a05188a5c95e6bf0db308ba7ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="eig_8h.html#d407ab076d4a366adcb42e8549db2305">eig_vectors</a> (double **A, size_t n, size_t low, size_t high, double *wr, double *wi, double **Q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Вычисление собственных векторов по методу обратной итерации.  <a href="#d407ab076d4a366adcb42e8549db2305"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Подробное описание</h2>
Проблема собственных значений. 
<p>
Пусть <img class="formulaInl" alt="$A$" src="form_767.png"> --- квадратная матрица. <em>Собственным вектором</em> называется такой ненулевой вектор <img class="formulaInl" alt="$x$" src="form_40.png">, что <img class="formulaInl" alt="$Ax=\lambda x$" src="form_535.png"> для некоторого числа <img class="formulaInl" alt="$\lambda$" src="form_536.png">. При этом <img class="formulaInl" alt="$\lambda$" src="form_536.png"> называется <em>собственным значением</em> (или <em>собственным числом</em>). Проблема собственных значений заключается в нахождении части (или всех) собственных значений и (если требуется) соответствующих им собственных векторов.<p>
В библиотеке реализованы следующие алгоритмы решения проблемы собственных значений:<p>
<ul>
<li><img class="formulaInl" alt="$QR$" src="form_26.png">-алгоритм для симметричной вещественной матрицы. Вначале с помощью функции <a class="el" href="eig_8h.html#fbf02412f8eab9390ee067b063b1bc0b">eig_tridiag_reduction</a> необходимо привести матрицу к трехдиагональному виду. Затем необходимо вызвать функцию <a class="el" href="eig_8h.html#78db68ad25d74fbc89a39523c050e5d8">eig_tridiag</a>, которая ищет собственные значения и собственные векторы трехдиагональной матрицы.</li></ul>
<p>
<ul>
<li>Метод Якоби для симметричной вещественной матрицы. Алгоритм реализован в функции <a class="el" href="eig_8h.html#2e9fc4e1f537973409ca88b08534a69c">eig_jacobi</a>.</li></ul>
<p>
<ul>
<li><img class="formulaInl" alt="$QR$" src="form_26.png">-алгоритм для произвольной вещественной матрицы. Вначале матрица подобным преобразованием приводится к форме Хессенберга - матрице, в которой элементы ниже первой поддиагонали равны <img class="formulaInl" alt="$0$" src="form_314.png">. Затем применятся <img class="formulaInl" alt="$QR$" src="form_26.png">-алгоритм к полученной матрице Хессенберга. Обычный порядок вызова функций следующий:<ul>
<li><a class="el" href="eig_8h.html#ee133dfdb5a882f517f8fda6ddc6ada9">eig_balance</a> - балансирование матрицы перед ее приведением к форме Хессенберга (рекомендуется, но вызов функции не обязателен);</li><li><a class="el" href="eig_8h.html#e2b0a2e73beda2bf908dcf1575fb944a">eig_hess_reduction</a> - приведение к форме Хессенберга;</li><li><a class="el" href="eig_8h.html#a2e230849ca0b84faf88045e6c6ecab9">eig_hess_transform_matrix</a> - пересчет трансформирующей матрицы, приводящей к форме Хессенберга (необходимо вызвать, если нужны собственные векторы);</li><li><a class="el" href="eig_8h.html#8b87b34e7fa36007973b13d68cda22b6">eig_hess</a> - вычисление собственных чисел и собственных значений матрицы Хессенберга;</li><li><a class="el" href="eig_8h.html#51d2cf2b45610b86ca6257fd58b3aa08">eig_balance_inverse</a> - по собственным векторам сбалансированной матрицы ищутся собственные векторы исходной матрицы (необходимо вызвать, если нужны собственные векторы);</li><li><a class="el" href="eig_8h.html#c97ca0a05188a5c95e6bf0db308ba7ab">eig_norm_Inf</a> - нормировка собственных векторов (если необходимо). </li></ul>
</li></ul>
<hr><h2>Функции</h2>
<a class="anchor" name="ee133dfdb5a882f517f8fda6ddc6ada9"></a><!-- doxytag: member="eig.h::eig_balance" ref="ee133dfdb5a882f517f8fda6ddc6ada9" args="(double **A, size_t n, size_t *low, size_t *high, double *scal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_balance           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>scal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Балансирование вещественной матрицы. 
<p>
Балансирование вещественной матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> перед приведением ее к форме Хессенберга для дальнейшего нахождения собственных чисел. Собственные числа исходной и сбалансированной матрицы одни и те же. Определяются строки с нулями вне диагонали. Остальные строки и столбцы домножаются на скаляры с тем, чтобы их норма была близка к <img class="formulaInl" alt="$1$" src="form_153.png">. Строки с нулями вне диагонали имеют номера с <img class="formulaInl" alt="$0$" src="form_314.png"> по <img class="formulaInl" alt="$low - 1$" src="form_469.png"> и <img class="formulaInl" alt="$hight+1$" src="form_470.png"> по <img class="formulaInl" alt="$n-1$" src="form_471.png">. Элементы вектора <img class="formulaInl" alt="$scal$" src="form_528.png"> на этих позициях равны соответствующим собственным векторам, на остальных позициях --- соответствующим масштабным множителям. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a38">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="51d2cf2b45610b86ca6257fd58b3aa08"></a><!-- doxytag: member="eig.h::eig_balance_inverse" ref="51d2cf2b45610b86ca6257fd58b3aa08" args="(double **Q, size_t n, size_t low, size_t high, double *scal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_balance_inverse           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>scal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Обратное балансирование. 
<p>
По собственным векторам <img class="formulaInl" alt="$Q$" src="form_29.png">, найденным для сбалансированной матрицы <img class="formulaInl" alt="$A$" src="form_767.png">, находит собственные векторы исходной матрицы. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a44">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="8b87b34e7fa36007973b13d68cda22b6"></a><!-- doxytag: member="eig.h::eig_hess" ref="8b87b34e7fa36007973b13d68cda22b6" args="(double **A, size_t n, size_t low, size_t high, double *wr, double *wi, int matq, double **Q, size_t *iter, size_t *rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_hess           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Собственные числа и векторы матрицы Хессенберга. 
<p>
Для матрицы Хессенберга <img class="formulaInl" alt="$A$" src="form_767.png"> находит собственные числа и, если <img class="formulaInl" alt="$matq \ne 0$" src="form_517.png">, - собственные векторы. Действительные части собственных чисел возвращаются в векторе <img class="formulaInl" alt="$wr$" src="form_476.png">, мнимые --- <img class="formulaInl" alt="$wi$" src="form_477.png">. Для вещественных собственных чисел (<img class="formulaInl" alt="$wi[j]=0$" src="form_478.png">) столбец <img class="formulaInl" alt="$j$" src="form_138.png"> содержит соответствующий собственный вектор. Для пары комплексно сопряженных собственных чисел (<img class="formulaInl" alt="$wr[j]=wr[j+1]$" src="form_479.png">, <img class="formulaInl" alt="$wi[j]=-wi[j+1]$" src="form_480.png">) <img class="formulaInl" alt="$j\f$" src="form_481.png">-й столбец матрицы <img class="formulaInl" alt="$Q\f$" src="form_482.png"> содержит действительную часть <img class="formulaInl" alt="$j$" src="form_138.png">-го собственного вектора, а <img class="formulaInl" alt="$(j+1)$" src="form_483.png">-й - его мнимую часть. <img class="formulaInl" alt="$(j+1)$" src="form_483.png">-й собственный вектор комплексно сопряжен к нему. В векторе <img class="formulaInl" alt="$iter$" src="form_504.png"> возвращается число итераций, используемых для нахождения каждого собственного числа.<p>
Если <img class="formulaInl" alt="$matq = 0$" src="form_518.png">, то на место матрицы <img class="formulaInl" alt="$Q$" src="form_29.png"> ничего не записывается и можно задать <img class="formulaInl" alt="$Q = NULL$" src="form_519.png">.<p>
На выходе, если все прошло успешно, то <img class="formulaInl" alt="$rc = 0$" src="form_485.png">. В противном случае число итераций превысило 30 и в <img class="formulaInl" alt="$rc$" src="form_486.png"> возвращается количество верно найденных собственных чисел. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a43">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="e2b0a2e73beda2bf908dcf1575fb944a"></a><!-- doxytag: member="eig.h::eig_hess_reduction" ref="e2b0a2e73beda2bf908dcf1575fb944a" args="(double **A, size_t n, size_t low, size_t high, size_t *perm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_hess_reduction           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>perm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Приведение матрицы к верхней форме Хессенберга. 
<p>
Квадратная вещественная матрица <img class="formulaInl" alt="$A$" src="form_767.png"> порядка <img class="formulaInl" alt="$n$" src="form_37.png"> методом вращений Хаусхолдера приводится к верхней форме Хессенберга. На выходе элементы верхнего треугольника и поддиагонали матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> хранят соответствующие элементы матрицы Хессенберга. Остальные элементы хранят дополнительную информацию. На выходе <img class="formulaInl" alt="$perm$" src="form_472.png"> --- вектор перестановок --- в дальнейшем используется функцией elmtrans <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a40">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="a2e230849ca0b84faf88045e6c6ecab9"></a><!-- doxytag: member="eig.h::eig_hess_transform_matrix" ref="a2e230849ca0b84faf88045e6c6ecab9" args="(double **A, size_t n, size_t low, size_t high, size_t *perm, double **Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_hess_transform_matrix           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Трансформирующая матрица к верхней форме Хессенберга. 
<p>
Для квадратной вещественной матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> порядка <img class="formulaInl" alt="$n$" src="form_37.png"> строит трансформирующую матрицу <img class="formulaInl" alt="$Q$" src="form_29.png">, приводящую к верхней форме Хессенберга. На входе параметры <img class="formulaInl" alt="$low$" src="form_473.png">, <img class="formulaInl" alt="$high$" src="form_474.png"> --- из функции <a class="el" href="eig_8h.html#ee133dfdb5a882f517f8fda6ddc6ada9">eig_balance</a>, <img class="formulaInl" alt="$A$" src="form_767.png">, <img class="formulaInl" alt="$perm$" src="form_472.png"> --- из <a class="el" href="eig_8h.html#8b87b34e7fa36007973b13d68cda22b6">eig_hess</a> <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a42">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="2e9fc4e1f537973409ca88b08534a69c"></a><!-- doxytag: member="eig.h::eig_jacobi" ref="2e9fc4e1f537973409ca88b08534a69c" args="(double **A, size_t n, double *w, int matq, double **Q, int *nrot, int *rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_jacobi           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Метод Якоби решения симметричной проблемы собственных значений. 
<p>
Функция вычисляет все собственные числа и собственные векторы вещественной симметричной матрицы <img class="formulaInl" alt="$A$" src="form_767.png">, элементы верхнетреугольной части которой хранятся в соответствующих позициях в массиве <img class="formulaInl" alt="$A$" src="form_767.png">. На выходе элемены выше диагонали испорчены. В векторе <img class="formulaInl" alt="$w$" src="form_391.png"> возвращаются собственные числа. Если на входе <img class="formulaInl" alt="$matq \ne 0$" src="form_517.png">, то на выходе <img class="formulaInl" alt="$Q$" src="form_29.png"> содержит нормализованные собственные векторы. <img class="formulaInl" alt="$nrot$" src="form_468.png"> возвращает число использованных вращений Якоби.<p>
Если <img class="formulaInl" alt="$matq = 0$" src="form_518.png">, то на место матрицы <img class="formulaInl" alt="$Q$" src="form_29.png"> ничего не записывается и можно задать <img class="formulaInl" alt="$Q = NULL$" src="form_519.png">.<p>
На выходе, если все прошло успешно, то <img class="formulaInl" alt="$rc = 0$" src="form_485.png">. В противном случае число итераций превысило 50 и в <img class="formulaInl" alt="$rc$" src="form_486.png"> возвращается <img class="formulaInl" alt="$1$" src="form_153.png">. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xjacobi_8c-example.html#a65">xjacobi.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="c97ca0a05188a5c95e6bf0db308ba7ab"></a><!-- doxytag: member="eig.h::eig_norm_Inf" ref="c97ca0a05188a5c95e6bf0db308ba7ab" args="(double **Q, size_t n, double *wi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_norm_Inf           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>wi</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Нормирование собственных векторов. 
<p>
Нормировка собственных векторов по их чебышевой (Inf) норме. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeig_8c-example.html#a45">xeig.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="78db68ad25d74fbc89a39523c050e5d8"></a><!-- doxytag: member="eig.h::eig_tridiag" ref="78db68ad25d74fbc89a39523c050e5d8" args="(double *d, double *a, size_t n, int matq, double **Q, size_t *rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_tridiag           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Собственные числа симметричной трехдиагональной системы. 
<p>
<img class="formulaInl" alt="$QL$" src="form_465.png">-алгоритм с неявными сдвигами для нахождения собственных векторов и собственных чисел действительной симметричной трехдиагональной матрицы <img class="formulaInl" alt="$A$" src="form_767.png">. Матрица <img class="formulaInl" alt="$A$" src="form_767.png"> может быть получена с помощью функции <a class="el" href="eig_8h.html#fbf02412f8eab9390ee067b063b1bc0b">eig_tridiag_reduction</a>. На входе <img class="formulaInl" alt="$d$" src="form_124.png"> содержит диагональ матрицы <img class="formulaInl" alt="$A$" src="form_767.png">, на выходе - собственные числа Вектор <img class="formulaInl" alt="$e$" src="form_464.png"> на входе содержит поддиагональ матрицы <img class="formulaInl" alt="$A$" src="form_767.png">, на выходе вектор теряет свои значения.<p>
Если <img class="formulaInl" alt="$matq \ne 0$" src="form_517.png">, то ищутся также собственные векторы. Если необходимы собственные векторы трехдиагональной матрицы, то матрица <img class="formulaInl" alt="$Q$" src="form_29.png"> на входе должна быть единичной. Если нужно найти собственные векторы матрицы, к которой уже применяли функцию <a class="el" href="eig_8h.html#fbf02412f8eab9390ee067b063b1bc0b">eig_tridiag_reduction</a>, то <img class="formulaInl" alt="$Z$" src="form_466.png"> должна быть матрицей, возвращаемой функцией <a class="el" href="eig_8h.html#fbf02412f8eab9390ee067b063b1bc0b">eig_tridiag_reduction</a>. В обоих случаях <img class="formulaInl" alt="$k$" src="form_333.png">-й столбец возвращаемой матрицы <img class="formulaInl" alt="$Z$" src="form_466.png"> есть нормированный собственный вектор, соответствующий собственному числу <img class="formulaInl" alt="$d[k]$" src="form_467.png">. Если собственные векторы не нужны, то нужно положить <img class="formulaInl" alt="$matq = 0$" src="form_518.png">. В этом случае <img class="formulaInl" alt="$Q$" src="form_29.png"> не используется и может быть равной <img class="formulaInl" alt="$NULL$" src="form_521.png">.<p>
Если <img class="formulaInl" alt="$rc=0$" src="form_522.png">, то вычисление успешное, иначе на вычисление одного из собственных чисел было потрачено более <img class="formulaInl" alt="$30$" src="form_396.png"> итераций. В этом случае <img class="formulaInl" alt="$rc$" src="form_486.png"> возвращает количество верно найденных собственных чисел (и векторов). <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeigsym_8c-example.html#a54">xeigsym.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="fbf02412f8eab9390ee067b063b1bc0b"></a><!-- doxytag: member="eig.h::eig_tridiag_reduction" ref="fbf02412f8eab9390ee067b063b1bc0b" args="(double **A, size_t n, int matq, double *d, double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_tridiag_reduction           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Приведение симметричной матрицы к трехдиагональному виду. 
<p>
Приведение преобразованиями Хаусхолдера вещественной симметричной матрицы <img class="formulaInl" alt="$A$" src="form_767.png"> к трехдиагональному виду <img class="formulaInl" alt="$B=Q^{\rm T}AQ$" src="form_463.png">. <img class="formulaInl" alt="$d$" src="form_124.png"> возвращает диагональные элементы, <img class="formulaInl" alt="$a$" src="form_123.png"> --- поддиагональные элементы, <img class="formulaInl" alt="$a[0] = 0$" src="form_503.png">. Если <img class="formulaInl" alt="$matq \ne 0$" src="form_517.png">, то на выходе матрица <img class="formulaInl" alt="$A$" src="form_767.png"> заменяется на ортогональную матрицу <img class="formulaInl" alt="$Q$" src="form_29.png">, в противном случае в <img class="formulaInl" alt="$A$" src="form_767.png"> - ``случайные'' значения. <dl compact><dt><b>Примеры: </b></dt><dd>
<a class="el" href="xeigsym_8c-example.html#a52">xeigsym.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="d407ab076d4a366adcb42e8549db2305"></a><!-- doxytag: member="eig.h::eig_vectors" ref="d407ab076d4a366adcb42e8549db2305" args="(double **A, size_t n, size_t low, size_t high, double *wr, double *wi, double **Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eig_vectors           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Вычисление собственных векторов по методу обратной итерации. 
<p>
Вычисление собственных векторов матрицы Хессенберга по собственным числам. Автоматически вызывается функцией <a class="el" href="eig_8h.html#8b87b34e7fa36007973b13d68cda22b6">eig_hess</a>, если vec == 1 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Документация по NL. Последние изменения: Mon Oct 9 12:25:54 2006. Создано системой&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
