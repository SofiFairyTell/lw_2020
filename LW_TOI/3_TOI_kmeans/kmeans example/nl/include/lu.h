#ifndef __LU_H__
#define __LU_H__

/**
  \file
  \f$LU\f$-разложение.

  Файл содержит функции, реализующие и использующие \f$LU\f$-разложение
  квадратной матрицы.

  Произвольная квадратная матрица \f$A\f$ порядка \f$n\f$ допускает разложение
  вида \f$PA=LU\f$, где \f$P\f$ - матрица перестановок, \f$L\f$ -
  нижнетреугольная матрица с единичной диагональю, \f$U\f$ -
  верхнетреугольная матрица. Такое разложение используют для решения систем
  линейных уравнений \f$Ax=b\f$, заменяя данную систему на пару систем
  \f$Ly=Pb\f$ и \f$Ux=y\f$.
*/

/**
  \example xlu.c
*/

/**
  \f$LU\f$-разложение матрицы.

  Функция находит \f$LU\f$-разложение и оценку числа обусловленности квадратной
  матрицы \f$A\f$ порядка \f$n\f$. На выходе диагональ и верхнетреугольная часть
  матрицы \f$A\f$ содержат элементы матрицы \f$U\f$. Нижнетреугольная часть матрицы \f$A\f$
  содержит поддиагональные элементы матрицы \f$L\f$. Диагональные элементы
  матрицы \f$L\f$ равны \f$1\f$. Матрица перестановок \f$P\f$ представлена вектором
  перестановок \f$p\f$, в котором \f$p[j]\f$ - индекс ведущей строки на \f$j\f$-ой итерации. На
  выходе \f$sgn\f$ - определитель матрицы \f$P\f$. Функция возвращает нижнюю оценку числа обусловленности
  матрицы \f$A\f$ порядка \f$n\f$. Как правило, данная оценка отличается от настоящего
  числа обусловленности не более чем в \f$10\f$ раз.
  
  Для разложения используется алгоритм Гаусса с выбором главного элемента
  по столбцу. Для оценки числа обусловленности используется алгоритм,
  описанный в [FMM, KMN].
  
  Трудоемкость: \f$\frac{2}{3}n^3 + O(n^2)\f$ операций с плавающей запятой
*/
extern double lu_decomp(double** A, size_t n, size_t* p, int *sgn);


/**
  Решение системы линейных уравнений.

  Функция находит решение квадратной системы линейных уравнений \f$Ax=b\f$
  порядка \f$n\f$, используя предварительно найденное \f$LU\f$-разложение матрицы \f$A\f$,
  представленное матрицей \f$LU\f$ и вектором перестановок \f$p\f$, возвращаемыми
  функцией #lu_decomp. Решение \f$x\f$ записывается на месте вектора правой части
  \f$b\f$. Матрица \f$LU\f$ и вектор \f$p\f$ не меняются данной функцией и могут быть
  использованы для решения системы с другой правой частью.

  Используется алгоритм прямой и обратной подстановки.
  
  Трудоемкость: \f$2n^2 + O(n)\f$ операций с плавающей запятой
*/

/**
  Решение системы линейных уравнений.

  Функция находит решение квадратной системы линейных уравнений \f$Ax=b\f$ порядка \f$n\f$,
  используя предварительно найденное \f$LU\f$-разложение матрицы \f$A\f$, представленное
  матрицей \f$LU\f$ и вектором перестановок \f$p\f$, возвращаемыми функцией #lu_decomp.
  Решение \f$x\f$ записывается на месте вектора правой части \f$b\f$.
  Матрица \f$L\f$U и вектор \f$p\f$ не меняются данной функцией и могут быть использованы для
  решения системы с другой правой частью.

  Используется алгоритм прямой и обратной подстановки.
  
  Трудоемкость: \f$2n^2 + O(n)\f$ операций с плавающей запятой
*/
extern void lu_solve(double** LU, size_t n, size_t* p, double* b);

/**
  Один шаг итерационного уточнения решения системы линейных уравнений.

  Функция выполняет один шаг итерационного уточнения решения \f$x\f$ системы линейных 
  уравнений \f$Ax=b\f$. Используется предварительно найденное \f$LU\f$-разложение матрицы \f$A\f$, 
  представленное матрицей \f$LU\f$ и вектором перестановок \f$p\f$, возвращаемыми функцией #lu_decomp.
  Возвращается улучшенное решение \f$x\f$ и вектор невязки \f$r=Ax-b\f$.

  Используется следующий алгоритм: вначале вычисляется вектор \f$r'=Ax-b\f$,
  после этого с помощью функции #lu_solve решается система \f$Ar'=b\f$ и, наконец,
  определяется улучшенное решение \f$x=x-r\f$ и вектор невязки \f$Ax-b\f$.
 
  Трудоемкость: \f$2n^2 + O(n)\f$ операций с плавающей запятой
*/
extern void lu_improve(double** LU, size_t n, size_t* p, double* b, double* x, double* r);

/**
  Определитель матрицы.

  Функция возвращает определитель квадратной матрицы \f$A\f$ порядка \f$n\f$. Ииспользуется 
  предварительно найденное \f$LU\f$-разложение матрицы A, представленное матрицей \f$LU\f$ и 
  определителем \f$sgn\f$ матрицы перестановок \f$P\f$ (сам вектор перестановок не нужен), 
  возвращаемыми функцией #lu_decomp.

  Трудоемкость: \f$2n + O(1)\f$ операций с плавающей запятой
*/
extern double lu_det(double** LU, size_t n, int sgn);

/**
  Обращение матрицы.

  Функция находит матрицу \f$B\f$, обратную к матрице \f$A\f$. Используется предварительно 
  найденное \f$LU\f$-разложение матрицы \f$A\f$, представленное матрицей \f$LU\f$ и вектором 
  перестановок \f$p\f$, возвращаемыми функцией #lu_decomp.

  Трудоемкость: \f$2n^2 + O(n)\f$ операций с плавающей запятой
*/
extern void lu_invert(double** LU, size_t n, size_t* p, double** B);


/**
  Умножение матрицы \f$A\f$, представленной массивами \f$LU\f$ и \f$p\f$, на вектор \f$v\f$. 

  Функция находит произведение \f$A\cdot v\f$.
  Используется предварительно 
  найденное \f$LU\f$-разложение матрицы \f$A\f$, представленное матрицей \f$LU\f$ и вектором 
  перестановок \f$p\f$, возвращаемыми функцией #lu_decomp. Результат возвращается
  в векторе \f$res\f$.

  Трудоемкость: \f$2n^2 + O(n)\f$ операций с плавающей запятой
*/
extern void lu_mult_col(double** LU, size_t n, size_t* p, double* v, double* res);

#endif
