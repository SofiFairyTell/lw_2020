#ifndef __CONV_H__
#define __CONV_H__

/**
  \file
  Построение выпуклой оболочки точек на плоскости.
*/

/**
  \example xqhull.c
*/

/**
  \example xandrew.c
*/

/**
  Алгоритм QuickHull построения выпуклой оболочки точек на плоскости.

  - Вход:
    - \f$x\f$, \f$y\f$ - координаты точек
    - \f$n\f$ - количество точек
    - \f$k\f$ - массив длины не менее \f$n\f$
    - \f$stack\f$ - массив длины не менее \f$4 \log n\f$

  - Выход:
    - \f$k\f$ - номера точек, являющихся вершинами выпуклой оболочки, 
          в порядке положительного обхода (против часовой стрелки)
    - \f$nk\f$ - число вершин выпуклой оболочки

  Трудоемкость: \f$O(n \cdot nk)\f$
*/

extern void conv_qhull(double* x, double* y, size_t n, size_t* k, size_t* nk, size_t* stack);

/**
  Точка на плоскости.

  Структура для хранения информации о точках.
  Используется в методе #conv_andrew.
*/
typedef struct 
{
  double x; ///< координата \f$x\f$
  double y; ///< координата \f$x\f$
  size_t k; ///< номер точки в заданном массиве
} conv_point;

/**
  Алгоритм Эндрю (модификация обхода Грэхема) построения выпуклой оболочки точек на плоскости.

  - Вход:
    - \f$x\f$, \f$y\f$ - координаты точек
    - \f$n\f$ - количество точек
    - \f$p\f$ - массив длины не менее \f$n\f$

  - Выход:
    - \f$p\f$ - точки, являющиеся вершинами выпуклой оболочки, 
          в порядке положительного обхода (против часовой стрелки)
    - \f$nk\f$ - число вершин выпуклой оболочки

  Трудоемкость: \f$O(n \log n)\f$
*/
extern void conv_andrew(const double* x, const double* y, size_t n, conv_point* p, size_t* nk);


#endif
