#ifndef __SPARSE_H__
#define __SPARSE_H__

/**
  \file
  Разреженные матрицы.

  Файл содержит функции, поддерживающие работу с
  разреженными матрицами.

  Для представления разреженных матриц общего вида в библиотеке
  используются так называемые RR(C)O и RR(C)U-форматы (row-wise
  representation complete and ordered и row-wise representation complete
  and unordered соответственно). С каждой матрицей \f$A\f$ в этих форматах
  связаны одномерный массив элементов \f$AN\f$ и два массива указателей: \f$JA\f$ и \f$IA\f$.
  Все ненулевые элементы хранятся построчно в массиве \f$AN\f$. Индексы столбцов
  ненулевых элементов - в массиве \f$JA\f$. Элементы массива \f$IA\f$ указывают на
  позиции, с которых начинается описание очередной строки. Более точно,
  описание \f$r\f$-й строки хранится в позициях с \f$IA[r]\f$ до \f$IA[r+1]-1\f$ массивов \f$JA\f$
  и \f$AN\f$. Если \f$IA[r]=IA[r+1]\f$, то \f$r\f$-ая строка пустая. Отличие формата RR(C)O от
  RR(C)U в том, что при использовании первого формата ненулевые элементы
  внутри каждой строки храняться упорядоченно, при использовании второго
  ненулевые элементы внутри одной строки могут храниться в произвольном
  порядке.

  Для представления разреженных симметричных матриц используются RR(U)O и
  RR(U)U-форматы. Отличие этих форматов от двух предыдущих в том, что, в
  массивах \f$IA\f$, \f$JA\f$, \f$AN\f$ хранится информация об элементах матрицы, лежащих
  выше диагонали, диагональные элементы (в том числе нулевые) хранятся
  отдельно в одномерном массиве \f$AD\f$.

  Подробно различные форматы хранения разреженных матриц опиcаны в 
  [ZolotykhBelov] и [Pissanezki]
*/

/**
  \example xsparse.c
*/

/**
  \example xspchol.c
*/

/**
  \example xspseid.c
*/

/**
  \example xspbicnj.c
*/

/**
  \example xspconjs.c
*/


/**
  \name Создание, освобождение и преобразование разреженных матриц
*/

/**
  Выделение памяти под разреженную матрицу.
  - Вход:  
      - \f$m\f$  - число строк матрицы \f$A\f$
      - \f$nz\f$ - число ненулевых элементов матрицы \f$A\f$
  - Выход: \f$IA\f$, \f$JA\f$, \f$AN\f$ - массивы под представление матрицы в RR(C)U-формате
*/
extern void sp_create(size_t m, size_t nz, size_t **IA, size_t **JA, double **AN);


/**
  Выделение памяти под разреженную симметричную матрицу.
  - Вход:  
     - \f$n\f$  - порядок матрицы \f$A\f$
     - \f$nz\f$ - число ненулевых элементов матрицы \f$A\f$
  - Выход: \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - массивы под представление матрицы в RR(U)U-формате
*/
extern void sp_create_sym(size_t n, size_t nz, size_t **IA, size_t **JA, double **AN, double **AD);


/**
  Возвращает число ненулевых элементов в разреженном представлении матрицы.
  - Вход:
     - \f$m\f$ - число строк матрицы \f$A\f$
	 - \f$IA\f$ - массив описания строк в RR(C)U-формате
  - Результат:
     - число ненулевых элементов 
*/
extern size_t sp_nz(size_t m, size_t* IA);

/**
  Конвертация плотного представления матрицы общего вида в разреженное.
  - Вход:  
         - \f$A\f$ - плотное представление матрицы
         - \f$m\f$ - число строк матрицы \f$A\f$
         - \f$n\f$ - число столбцов матрицы \f$A\f$
         - \f$eps\f$ - элементы, меньшие \f$eps\f$ будут обнулены
  - Выход:
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)O-формате
  
  Трудоемкость: 
*/
extern void sp_sparse(double** A, size_t m, size_t n, size_t** IA, size_t** JA, double** AN, double eps);


/**
  Конвертация плотного представления симметричной матрицы в разреженное.
  - Вход: 
         - \f$A\f$ - плотное представление симметричной матрицы
         - \f$n\f$ - порядок матрицы \f$A\f$
         - \f$eps\f$ - элементы, меньшие \f$eps\f$ будут обнулены
  - Выход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)O-формате

  Трудоемкость: 
*/
extern void sp_sparse_sym(double** A, size_t n, size_t** IA, size_t** JA, double** AN, double** AD, double eps);

/**
  Конвертация разреженного представления матрицы общего вида в плотное.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
  - Выход: 
         - \f$A\f$ - плотное представление симметричной матрицы

  Трудоемкость: 
*/
extern void sp_full(size_t* IA, size_t* JA, double* AN, size_t m, size_t n, double** A);

/**
  Конвертация разреженного представления симметричной матрицы в плотное.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         - \f$n\f$ - порядок матрицы \f$A\f$
  - Выход: 
         - \f$A\f$ - плотное представление симметричной матрицы

  Трудоемкость: 
*/
extern void sp_full_sym(size_t* IA, size_t* JA, double* AN, double* AD, size_t n, double** A);


/**
  Конвертация разреженного симметричной матрицы из формата RR(U)U в RR(C)U.

  Память под выходную матрицу должна быть выделена, так что число ненулевых
  элементов должн быть не меньше \f$2*nz + n\f$, где \f$nz\f$ -- число ненулевых 
  элементов в исходной матрице.
  
  Пример: sp_create(n, 2*sp_nz(n,IS) + n, &IA, &JA, &AN)

  - Вход: 
         - \f$IS\f$, \f$JS\f$, \f$SN\f$, \f$SD\f$ - разреженное представление матрицы в RR(U)U-формате
         - \f$n\f$ - порядок матрицы
  - Выход: 
		 - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
  Трудоемкость: 
*/
extern void sp_sym_to_complete(size_t *IS, size_t *JS, double* SN, double* SD, size_t n, size_t *IA, size_t *JA, double *AN);


/**
  Освобождение памяти, выделенной под разреженную матрицу.
  Вход:  \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         \f$n\f$ - порядок матрицы \f$A\f$                  

*/
extern void sp_free(size_t* IA, size_t* JA, double* AN);


/**
  Освобождение памяти, выделенной под разреженную симметричную матрицу.
  Вход:  \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         \f$n\f$ - порядок матрицы \f$A\f$                  

*/
extern void sp_free_sym(size_t* IA, size_t* JA, double* AN, double* AD);


/**
  Получение списка всех ненулевых элементов разреженной матрицы.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
  - Выход: 
         - \f$A\f$ - массив ненулевых элементов матрицы
         - \f$I\f$, \f$J\f$ - индексы строк и столбцов ненулевых элементов матрицы
  - Результат:
         - число ненулевых элементов  

  Трудоемкость: 
*/
extern size_t sp_list(size_t* IA, size_t* JA, double* AN, size_t m, double* A, size_t* I, size_t* J);

/**
  Построение разреженной матрицы по списку ненулевых элементов.
  - Вход: 
         - \f$nz\f$ - число ненулевых элементов
         - \f$A\f$ - массив ненулевых элементов матрицы
         - \f$I\f$, \f$J\f$ - индексы строк и столбцов ненулевых элементов матрицы
         - \f$m\f$ - число строк матрицы \f$A\f$                     
  - Выход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате

  Трудоемкость: 
*/
extern void sp_convert(size_t nz, double* A, size_t* I, size_t* J, size_t m, size_t* IA, size_t* JA, double* AN);


/**
  Упорядочение представления разреженной матрицы общего вида.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$
  - Выход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление исходной матрицы в RR(C)O-формате

  Трудоемкость:
*/
extern void sp_order(size_t* IA, size_t* JA, double* AN, size_t m);

/**
  Упорядочение портрета разреженной матрицы общего вида.
  - Вход: 
         - \f$IA\f$, \f$JA\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$
  - Выход: 
         - \f$IA\f$, \f$JA\f$ - разреженное представление исходной матрицы в RR(C)O-формате

  Трудоемкость:
*/
extern void sp_order_m(size_t* IA, size_t* JA, size_t m);






//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/**
  \name Ввод и вывод разреженных матриц
*/

/**
  Форматированный вывод разреженной матрицы на экран.
  Выводятся размеры матрицы, а затем три вектора, которые задают 
  разреженное представление матрицы: \f$IA\f$, \f$JA\f$, \f$AN\f$.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
         - \f$format\f$ - формат представления элементов матрицы

*/
extern void sp_print(size_t* IA, size_t* JA, double* AN, size_t m, size_t n, const char* format);

/**
  Форматированный вывод разреженной матрицы на экран.
  Выводятся размеры матрицы и число ненулевых элементов. Затем матрица 
  выводится в виде списка ненулевых элементов с указанием их позиций.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
         - \f$xformat\f$ - формат представления позиций элементов матрицы
         - \f$dformat\f$ - формат представления элементов матрицы

*/
extern void sp_print_list(size_t* IA, size_t* JA, double* AN, size_t m, size_t n, const char* xformat, const char* dformat);

/**
  Форматированный вывод разреженной матрицы в файл.
  Выводятся размеры матрицы, а затем три вектора, которые задают 
  разреженное представление матрицы: \f$IA\f$, \f$JA\f$, \f$AN\f$.
  - Вход: 
         - \f$file\f$ - файл, в который осуществляется вывод
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
         - \f$format\f$ - формат представления элементов матрицы
*/
extern void sp_fprint(FILE* file, size_t* IA, size_t* JA, double* AN, size_t m, size_t n, const char* format);

/**
  Форматированный вывод разреженной матрицы на экран.
  Выводятся размеры матрицы и число ненулевых элементов. Затем выводится 
  матрица в виде списка ненулевых элементов с указанием их позиций.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
         - \f$xformat\f$ - формат представления позиций элементов матрицы
         - \f$dformat\f$ - формат представления элементов матрицы
*/
extern void sp_fprint_list(FILE* file, size_t* IA, size_t* JA, double* AN, size_t m, size_t n, const char* xformat, const char* dformat);


/**
  Чтение разреженной матрицы с клавиатуры.
  Функция считывает с клавиатуры число строк и число столбцов, размещает 
  память под структуру хранения разреженной матрицы, а затем
  считывает векторы представления разреженной матрицы.
  - Вход: 
  - Выход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.
*/
extern int sp_scan(size_t** IA, size_t** JA, double** AN, size_t* m, size_t* n);

/**
  Чтение разреженной матрицы из файла.
  Функция считывает с клавиатуры число строк и число столбцов, размещает 
  память под структуру хранения разреженной матрицы, а затем
  считывает векторы представления разреженной матрицы.
  - Вход: 
  - Выход: 
         - \f$file\f$ - файл
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.
*/
extern int sp_fscan(FILE* file, size_t** IA, size_t** JA, double** AN, size_t* m, size_t* n);









//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/**
  \name Ввод и вывод симметричных разреженных матриц
*/

/**
  Форматированный вывод симметричной разреженной матрицы на экран.
  Выводятся размер матрицы и четыре вектора, которые задают 
  разреженное представление матрицы: \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление симметричной матрицы в RR(U)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$                  
         - \f$xformat\f$ - формат представления позиций элементов матрицы
         - \f$dformat\f$ - формат представления элементов матрицы

*/
extern void sp_print_sym(size_t* IA, size_t* JA, double* AN, double* AD, size_t n, const char* format);

/**
  Форматированный вывод симметричной разреженной матрицы на экран.
  Выводятся размеры матрицы и общее число ненулевых элементов, задающих
  разреженное представление (число ненулевых элементов выше диагонали 
  плюс диагональные элементы). Затем выводится матрица в виде списка 
  ненулевых элементов с указанием их позиций.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$                  
         - \f$xformat\f$ - формат представления позиций элементов матрицы
         - \f$dformat\f$ - формат представления элементов матрицы

*/
extern void sp_print_list_sym(size_t* IA, size_t* JA, double* AN, double* AD, size_t n, const char* xformat, const char* dformat);

/**
  Форматированный вывод разреженной матрицы в файл.
  Выводятся размер матрицы и четыре вектора, которые задают 
  разреженное представление матрицы: \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$.
  - Вход: 
         - \f$file\f$ - файл, в который осуществляется вывод
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$                  
         - \f$format\f$ - формат представления элементов матрицы

*/
extern void sp_fprint_sym(FILE* file, size_t* IA, size_t* JA, double* AN, double* AD, size_t n, const char* format);

/**
  Форматированный вывод симметричной разреженной матрицы в файл.
  Выводятся размер матрицы и общее число ненулевых элементов, задающих
  разреженное представление (число ненулевых элементов выше диагонали 
  плюс диагональные элементы). Затем выводится матрица в виде списка 
  ненулевых элементов с указанием их позиций.
  - Вход: 
         - \f$file\f$ - файл, в который осуществляется вывод
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(U)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$                  
         - \f$xformat\f$ - формат представления позиций элементов матрицы
         - \f$dformat\f$ - формат представления элементов матрицы

*/
extern void sp_fprint_list_sym(FILE* file, size_t* IA, size_t* JA, double* AN, double* AD, size_t n, const char* xformat, const char* dformat);

/**
  Чтение разреженной матрицы с клавиатуры.
  Функция считывает с клавиатуры число строк/столбцов, размещает 
  память под структуру хранения разреженной матрицы, а затем
  считывает вектора представляения разреженной матрицы.
  - Вход: 
  - Выход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.
*/
extern int sp_scan_sym(size_t** IA, size_t** JA, double** AN, double** AD, size_t* n);

/**
  Чтение разреженной матрицы из файла.
  Функция считывает из файла число строк/столбцов, размещает 
  память под структуру хранения разреженной матрицы, а затем
  считывает вектора представляения разреженной матрицы.
  - Вход: 
  - Выход: 
         - \f$file\f$ - файл
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$n\f$ - число строк/столбцов матрицы \f$A\f$
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.
*/
extern int sp_fscan_sym(FILE* file, size_t** IA, size_t** JA, double** AN, double** AD, size_t* n);








//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/**
  \name Операции с разреженными матрицами
*/



/**
  Транспонирование разреженной матрицы.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$                  
  - Выход: 
         - \f$IAT\f$, \f$JAT\f$, \f$ANT\f$ - разреженное представление транспонированной матрицы в RR(C)O-формате

  Трудоемкость: 
*/
extern void sp_transpose(size_t* IA, size_t* JA, double* AN, size_t m, size_t n, size_t* IAT, size_t* JAT, double* ATN);

/**
  Символическое сложение разреженных матриц.
  - Вход: 
         - \f$IA\f$, \f$JA\f$ - портрет матрицы \f$A\f$ в RR(C)U-формате
         - \f$IB\f$, \f$JB\f$ - портрет матрицы \f$B\f$ в RR(C)U-формате
         - \f$m\f$ - число строк матриц \f$A\f$ и \f$B\f$                     
         - \f$n\f$ - число столбцов матриц \f$A\f$ и \f$B\f$                  
         - \f$size_C\f$ - размер массива \f$JC\f$. Если размер не достаточен, программа 
		 аварийно завершит работу, с кодом #nl_err_inconsistent_size
  - Выход: 
         - \f$IC\f$, \f$JC\f$ - портрет суммы \f$A+B\f$ в RR(C)U-формате 
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.

  Трудоемкость:
*/
extern int sp_add_symb(size_t* IA, size_t* JA, size_t* IB, size_t* JB, size_t m, size_t n, size_t* IC, size_t* JC, size_t size_C);


/**
  Численное сложение разреженных матриц.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
         - \f$IB\f$, \f$JB\f$, \f$BN\f$ - разреженное представление матрицы \f$B\f$ в RR(C)U-формате
         - \f$IC\f$, \f$JC\f$ - портрет суммы \f$A+B\f$ в RR(U)U-формате
         - \f$m\f$ - число строк матриц \f$A\f$, \f$B\f$, \f$C\f$
         - \f$n\f$ - число столбцов матриц \f$A\f$, \f$B\f$, \f$C\f$
  - Выход: 
         - \f$CN\f$ - численные значения ненулевых элементов суммы \f$A+B\f$

  Трудоемкость:
*/
extern void sp_add_num(size_t* IA, size_t* JA, double* AN, size_t* IB, size_t* JB, double* BN, size_t m, size_t n, size_t* IC, size_t* JC, double* CN);

/**
  Умножение разреженной матрицы на плотный столбец.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
         - \f$b\f$ - плотный вектор-столбец
         - \f$m\f$ - число строк матрицы \f$A\f$                     
  - Выход: 
         - \f$c\f$ - произведение \f$A\cdot b\f$

  Трудоемкость:
*/
extern void sp_mult_col(size_t* IA, size_t* JA, double* AN, double* b, size_t m, double* c);


/**
  Умножение плотной строки на разреженную матрицу.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
         - \f$b\f$ - плотный вектор-строка
         - \f$m\f$ - число строк матрицы \f$A\f$                     
         - \f$n\f$ - число столбцов матрицы \f$A\f$
  - Выход: 
         - \f$c\f$ - произведение \f$b*A\f$

  Трудоемкость:
*/
extern void sp_mult_row(size_t* IA, size_t* JA, double* AN, double* b, size_t m, size_t n, double* c);

/**
  Умножение симметричной матрицы на плотный столбец.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы \f$A\f$ в RR(U)U-формате
         - \f$b\f$ - плотный вектор-строка
         - \f$n\f$ - порядок матрицы \f$A\f$
  - Выход: 
         - \f$c\f$ - произведение \f$A\cdot b\f$

  Трудоемкость:
*/
extern void sp_mult_col_sym(size_t* IA, size_t* JA, double* AN, double* AD, double* b, size_t n, double* c);

/**
  Символическое умножение разреженных матриц.
  - Вход: 
         - \f$IA\f$, \f$JA\f$ - портрет матрицы \f$A\f$ в RR(C)U-формате
         - \f$IB\f$, \f$JB\f$ - портрет матрицы \f$B\f$ в RR(C)U-формате
         - \f$m\f$ - число строк матрицы \f$A\f$
         - \f$k\f$ - число столбцов матрицы \f$B\f$
         - \f$size_C\f$ - размер массива \f$JC\f$. Если размер не достаточен, программа 
		 аварийно завершит работу, с кодом #nl_err_inconsistent_size
  - Выход: 
         - \f$IC\f$, \f$JC\f$ - портрет произведения \f$A \cdot B\f$ в RR(C)U-формате 
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.

  Трудоемкость:
*/
extern int sp_mult_symb(size_t* IA, size_t* JA, size_t* IB, size_t* JB, size_t m, size_t k, size_t* IC, size_t* JC, size_t size_C);

/**
  Численное умножение разреженных матриц.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
         - \f$IB\f$, \f$JB\f$, \f$BN\f$ - разреженное представление матрицы \f$B\f$ в RR(C)U-формате
         - \f$IC\f$, \f$JC\f$ - портрет произведения \f$A\cdot B\f$ в RR(C)U-формате 
         - \f$m\f$ - число строк матриц \f$A\f$ и \f$A\cdot B\f$
         - \f$k\f$ - число столбцов матриц \f$B\f$ и \f$A\cdot B\f$
  - Выход: 
         - \f$CN\f$ - численные значения ненулевых элементов произведения \f$A\cdot B\f$

  Трудоемкость:
*/
extern void sp_mult_num(size_t* IA, size_t* JA, double* AN, size_t* IB, size_t* JB, double* BN, size_t* IC, size_t* JC, size_t m, size_t k, double* CN);


/**
  Заполнение вектора, так что \f$i\f$-я компонента равна числу ненулевых элементов 
  в \f$i\f$-й строке/столбце симметричной разреженной матрицы.

  Трудоемкость: \f$n + nz\f$;
*/
extern void sp_row_nz_sym(size_t* IA, size_t* JA, size_t n, size_t* nz);


/**
  Выдаёт вектор перестановок, такой, что столбцы матрицы будут расположены
  по неубыванию числа ненулевых элементов в них.
  - Вход: 
         - \f$IA\f$, \f$JA\f$ - портрет матрицы \f$A\f$ в RR(U)U-формате
         - \f$n\f$ - порядок матрицы \f$A\f$
  - Выход: 
         - вектор перестановок

  Трудоемкость: \f$nz\log(nz) + n\f$
*/
extern void sp_colperm_sym(size_t* IA, size_t* JA, size_t n, size_t* p);

/**
Перестановка строк и столбцов симметричной матрицы
*/	
extern void sp_permute_sym(
	size_t n,
	size_t *IA,
	size_t *JA,
	size_t *IB,
	size_t *JB,
	double *AN,
	double *AD,
	double *BN,
	double *BD,
	size_t *IP);





//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/**
  \name Решение систем уравнений с разреженными матрицами
*/


/**
  Символическое треугольное разложение (Холецкого) разреженной симметричной
  матрицы.
  Процедура строит символическое треугольное разложение симметричной матрицы A
  вида \f$A=U^{\rm T} U\f$.
  - Вход: 
         - \f$IA\f$, \f$JA\f$ - портрет матрицы \f$A\f$ в RR(U)U-формате
         - \f$n\f$ - порядок матрицы \f$A\f$
         - \f$size_U\f$ - размер массива \f$JU\f$. Если размер не достаточен, программа 
		 аварийно завершит работу, с кодом #nl_err_inconsistent_size
  - Выход: 
         - \f$IU\f$, \f$JU\f$ - портрет матрицы \f$U\f$ в RR(U)U-формате
  - Результат:
         \f$0\f$, если произошла ошибка, и не \f$0\f$ если функция успешно завершилась.

  Трудоемкость:
*/
extern int sp_chol_symb(size_t* IA, size_t* JA, size_t n, size_t* IU, size_t* JU, size_t size_U);

/**
  Численное треугольное разложение (Холецкого) разреженной симметричной
  положительно определенной матрицы.
  Процедура строит численное треугольное разложение симметричной
  положительно определенной матрицы \f$A\f$ вида \f$A=U^{\rm T}U\f$.
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы \f$A\f$ в RR(U)U-формате
         - \f$IU\f$, \f$JU\f$ - портрет матрицы \f$U\f$ в RR(C)O-формате
         - \f$n\f$ - порядок матрицы \f$A\f$
  - Выход: 
         - \f$UN\f$ - численные значения ненулевых элементов матрицы \f$U\f$
         - \f$DINV\f$ - значения диагональных элементов матрицы, обратной к \f$D\f$
  Трудоемкость:
*/
extern void sp_chol_num(size_t* IA, size_t* JA, double* AN, double* AD, size_t* IU, size_t* JU, size_t n, double* UN, double* DINV);

/**
  Решение симметричной разреженной системы линейных уравнений \f$Ax=b\f$ методом
  Холецкого.
  - Вход: 
         - \f$IU\f$, \f$JU\f$, \f$UN\f$ - разреженное представление верхней треугольной матрицы
             \f$U\f$ с единичной диагональю в RR(U)O-формате (диагональ не хранится)
         - \f$DINV\f$ - значения диагональных элементов матрицы, обратной к \f$D\f$
         - \f$b\f$ - вектор правых частей системы
         - \f$n\f$ - порядок системы
  - Выход: 
         - \f$x\f$ - найденное решение

  Трудоемкость:
*/
extern void sp_chol_solve(size_t* IU, size_t* JU, double* UN, double* DINV, double* b, size_t n, double* x);

/**
  Решение разреженной системы линейных уравнений \f$Ax=b\f$ методом Гаусса-Зейделя 
  (с выбором параметра релаксации).
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление матрицы \f$A\f$ в RR(LU)U-формате
            (Row - wise Representation, Lower - Upper, Unordered, то есть строчное 
			представление, нижний треугольник - верхний треугольник, 
			неупорядоченное) -- диагональные элементы в отдельном массиве.
         - \f$b\f$ - вектор правых частей системы
         - \f$n\f$ - порядок системы
         - \f$f\f$ - параметр релаксации
         - \f$eps\f$ - допуск на абсолютную величину приращения в тесте на сходимость
         - \f$max\_iter\f$ - максимальное количество итераций
  - Выход: 
         - \f$x\f$ - найденное решение
  - Результат:
         - число итераций затраченных на поиск решения

  Трудоемкость:
*/
extern int sp_gauss_seidel(size_t* IA, size_t* JA, double* AN, double* AD, double* b, size_t n, double f, double eps, int max_iter, double* x);

/**
  Решение разреженной системы линейных уравнений \f$Ax=b\f$ методом Гаусса-Зейделя 
  (с выбором параметра релаксации).
  - Вход: 
         - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
         - \f$b\f$ - вектор правых частей системы
         - \f$n\f$ - порядок системы
         - \f$f\f$ - параметр релаксации
         - \f$eps\f$ - допуск на абсолютную величину приращения в тесте на сходимость
         - \f$max\_iter\f$ - максимальное количество итераций
  - Выход: 
         - \f$x\f$ - найденное решение
  - Результат:
         - число итераций затраченных на поиск решения, если функция 
		 успешна завершилась и \f$-1\f$ если произошла ошибка.

  Трудоемкость:
*/
extern int sp_gauss_seidel_m(size_t* IA, size_t* JA, double* AN, double* b, size_t n, double f, double eps, int max_iter, double* x);

/*
  Решение разреженной симметричной системы линейных уравнений \f$Ax=b\f$ методом сопряженных градиентов.

  Вариант из библиотеки НИВЦ МГУ
  - Вход:
	- \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление симметричной матрицы \f$A\f$ в RR(C)U-формате
        - \f$b\f$ - вектор правых частей системы
	- \f$n\f$ - порядок системы
	- \f$eps\f$ - заданная точность, с которой необходимо вычислить решение системы
	- \f$max\_iter\f$ - максимальное количество итераций  
	- \f$x\f$ - начальное приближение решения
  - Выход:
	- \f$x\f$ - найденное решение
	- \f$RSQ\f$ вычисленная сумма квадратов компонент вектора невязки \f$Ax - b\f$;
  - Результат:
	- число итераций затраченных на поиск решения

  Трудоемкость:
*/
extern int sp_conj_nivc(size_t* IA, size_t* JA, double* AN, double* b, size_t n, double eps, int max_iter, double* x, double* RSQ);

/**
  Решение разреженной симметричной системы линейных уравнений \f$Ax=b\f$ 
  методом сопряженных градиентов.

  В отличие от функции #sp_conj_sym матрица \f$A\f$
  представлена в RR(C)U-формате
  - Вход:
        - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление симметричной матрицы \f$A\f$ в RR(C)U-формате
        - \f$b\f$ - вектор правых частей системы
        - \f$n\f$ - порядок системы
        - \f$eps\f$ - заданная точность, с которой необходимо вычислить решение системы
        - \f$max\_iter\f$ - максимальное количество итераций  
        - \f$x\f$ - начальное приближение решения
  - Выход:
        - \f$x\f$ - найденное решение

  Трудоемкость:
*/
extern int sp_conj(size_t* IA, size_t* JA, double* AN, double* b, size_t n, double eps, int max_iter, double* x);

/**
  Решение разреженной симметричной системы линейных уравнений \f$Ax=b\f$ 
  методом сопряженных градиентов. 

  В отличие от функции #sp_conj матрица \f$A\f$
  представлена в RR(U)U-формате
  - Вход:
        - \f$IA\f$, \f$JA\f$, \f$AN\f$, \f$AD\f$ - разреженное представление симметричной матрицы \f$A\f$ в RR(U)U-формате
        - \f$b\f$ - вектор правых частей системы
        - \f$n\f$ - порядок системы
        - \f$eps\f$ - заданная точность, с которой необходимо вычислить решение системы
        - \f$max\_iter\f$ - максимальное количество итераций  
        - \f$x\f$ - начальное приближение решения
  - Выход:
        - \f$x\f$ - найденное решение

  Функция возвращает значение, на \f$1\f$ меньшее количества выполненных итераций.
  Если это значение равно \f$max\_iter\f$, то заданная точность не достигнута

  Трудоемкость:
*/
extern int sp_conj_sym(size_t *IA, size_t *JA, double *AN, double *AD, double *b, size_t n, double eps, int max_iter, double *x);

/**
  Решение разреженной системы линейных уравнений \f$Ax=b\f$ методом бисопряженных градиентов.
  - Вход:
        - \f$IA\f$, \f$JA\f$, \f$AN\f$ - разреженное представление матрицы \f$A\f$ в RR(C)U-формате
        - \f$b\f$ - вектор правых частей системы
        - \f$n\f$ - порядок системы
        - \f$eps\f$ - заданная точность, с которой необходимо вычислить решение системы
        - \f$max\_iter\f$ - максимальное количество итераций  
        - \f$x\f$ - начальное приближение решения
  - Выход:
        - \f$x\f$ - найденное решение

  Функция возвращает значение, на \f$1\f$ меньшее количества выполненных итераций.
  Если это значение равно \f$max\_iter\f$, то заданная точность не достигнута

  Трудоемкость:
*/
extern int sp_biconj(size_t* IA, size_t* JA, double* AN, double* b, size_t n, double eps, int max_iter, double* x);

#endif
