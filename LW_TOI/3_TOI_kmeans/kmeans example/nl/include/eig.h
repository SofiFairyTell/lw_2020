#ifndef __EIG_H__
#define __EIG_H__

/**
  \file
  Проблема собственных значений.

  Пусть \f$A\f$ --- квадратная матрица. <i>Собственным вектором</i>
  называется такой ненулевой вектор \f$x\f$, что \f$Ax=\lambda x\f$ для
  некоторого числа \f$\lambda\f$. При этом \f$\lambda\f$ называется
  <i>собственным значением</i> (или <i>собственным числом</i>). Проблема
  собственных значений заключается в нахождении части (или всех)
  собственных значений и (если требуется) соответствующих им собственных
  векторов.

  В библиотеке реализованы следующие алгоритмы решения проблемы собственных значений:

    - \f$QR\f$-алгоритм для симметричной вещественной матрицы.
      Вначале с помощью функции #eig_tridiag_reduction необходимо привести матрицу к 
      трехдиагональному виду. Затем необходимо вызвать функцию #eig_tridiag,
      которая ищет собственные значения и собственные векторы трехдиагональной матрицы.

    - Метод Якоби для симметричной вещественной матрицы. Алгоритм реализован в функции #eig_jacobi.

    - \f$QR\f$-алгоритм для произвольной вещественной матрицы. Вначале матрица подобным
      преобразованием приводится к форме Хессенберга - матрице, в которой элементы ниже
      первой поддиагонали равны \f$0\f$. Затем применятся \f$QR\f$-алгоритм к полученной матрице 
      Хессенберга. Обычный порядок вызова функций следующий: 
        - #eig_balance - балансирование матрицы перед ее приведением 
          к форме Хессенберга (рекомендуется, но вызов функции не обязателен);
        - #eig_hess_reduction - приведение к форме Хессенберга;
        - #eig_hess_transform_matrix - пересчет трансформирующей матрицы, приводящей 
          к форме Хессенберга (необходимо вызвать, если нужны собственные векторы);
        - #eig_hess - вычисление собственных чисел и собственных значений матрицы Хессенберга;
        - #eig_balance_inverse - по собственным векторам сбалансированной матрицы ищутся 
          собственные векторы исходной матрицы (необходимо вызвать, если нужны собственные векторы);
        - #eig_norm_Inf - нормировка собственных векторов (если необходимо).
*/

/**
  \example xeig.c
*/

/**
  \example xeigsym.c
*/

/**
  \example xjacobi.c
*/


/**
  Приведение симметричной матрицы к трехдиагональному виду.

  Приведение преобразованиями Хаусхолдера вещественной симметричной матрицы \f$A\f$ к
  трехдиагональному виду \f$B=Q^{\rm T}AQ\f$. \f$d\f$ возвращает диагональные элементы, 
  \f$a\f$ --- поддиагональные элементы, \f$a[0] = 0\f$. Если \f$matq \ne 0\f$,
  то на выходе матрица \f$A\f$ заменяется
  на ортогональную матрицу \f$Q\f$, в противном случае в \f$A\f$ - ``случайные'' значения. 
*/

extern void eig_tridiag_reduction(double **A, size_t n, int matq, double *d, double *a);

/**
  Собственные числа симметричной трехдиагональной системы.

  \f$QL\f$-алгоритм с неявными сдвигами для нахождения собственных векторов и
  собственных чисел действительной симметричной трехдиагональной матрицы
  \f$A\f$. Матрица \f$A\f$ может быть получена с помощью функции #eig_tridiag_reduction. На входе
  \f$d\f$ содержит диагональ матрицы \f$A\f$, на выходе - собственные числа Вектор
  \f$e\f$ на входе содержит поддиагональ матрицы \f$A\f$, на выходе вектор теряет
  свои значения. 
  
  Если \f$matq \ne 0\f$, то ищутся также собственные векторы.
  Если необходимы собственные векторы трехдиагональной
  матрицы, то матрица \f$Q\f$ на входе должна быть единичной. Если нужно найти
  собственные векторы матрицы,  к которой уже применяли функцию #eig_tridiag_reduction, то
  \f$Z\f$ должна быть матрицей, возвращаемой функцией #eig_tridiag_reduction. В обоих случаях
  \f$k\f$-й столбец возвращаемой матрицы \f$Z\f$ есть нормированный собственный
  вектор, соответствующий собственному числу \f$d[k]\f$. Если собственные векторы не нужны,
  то нужно положить \f$matq = 0\f$. В этом случае \f$Q\f$ не используется и может
  быть равной \f$NULL\f$.
  
  Если \f$rc=0\f$, то вычисление успешное, иначе на вычисление одного из собственных
  чисел было потрачено более \f$30\f$ итераций. В этом случае \f$rc\f$ возвращает
  количество верно найденных собственных чисел (и векторов).  
*/
extern void eig_tridiag(double *d, double *a, size_t n, int matq, double **Q, size_t *rc);

/**
  Метод Якоби решения симметричной проблемы собственных значений.

  Функция вычисляет все собственные числа и собственные векторы вещественной
  симметричной матрицы \f$A\f$, элементы верхнетреугольной части которой хранятся 
  в соответствующих позициях в массиве \f$A\f$. На выходе элемены выше диагонали испорчены.
  В векторе \f$w\f$ возвращаются собственные числа. Если на входе \f$matq \ne 0\f$,
  то на выходе \f$Q\f$ содержит нормализованные собственные
  векторы. \f$nrot\f$ возвращает число использованных вращений Якоби.

  Если \f$matq = 0\f$, то на место матрицы \f$Q\f$ ничего не записывается и можно
  задать \f$Q = NULL\f$.

  На выходе, если все прошло успешно, то \f$rc = 0\f$.
  В противном случае число итераций превысило 50
  и в \f$rc\f$ возвращается \f$1\f$.

*/
extern void eig_jacobi(double **A, size_t n, double *w, int matq, double **Q, int *nrot, int *rc);


/** 
  Балансирование вещественной матрицы.

  Балансирование вещественной матрицы \f$A\f$ перед приведением ее к форме Хессенберга
  для дальнейшего нахождения собственных чисел.
  Собственные числа исходной и сбалансированной матрицы одни и те же.
  Определяются строки с нулями вне диагонали.
  Остальные строки и столбцы домножаются на скаляры с тем,
  чтобы их норма была близка к \f$1\f$.
  Строки с нулями вне диагонали имеют номера с \f$0\f$ по \f$low - 1\f$
  и \f$hight+1\f$ по \f$n-1\f$. Элементы вектора \f$scal\f$ на этих позициях 
  равны соответствующим собственным векторам, на остальных позициях ---
  соответствующим масштабным множителям.
*/
extern void eig_balance(double **A, size_t n, size_t *low, size_t *high, double *scal);


/**
  Приведение матрицы к верхней форме Хессенберга.

  Квадратная вещественная матрица \f$A\f$ порядка \f$n\f$ методом вращений Хаусхолдера
  приводится к верхней форме Хессенберга. На выходе элементы верхнего треугольника
  и поддиагонали матрицы \f$A\f$ хранят соответствующие элементы матрицы Хессенберга.
  Остальные элементы хранят дополнительную информацию. На выходе \f$perm\f$ ---
  вектор перестановок --- в дальнейшем используется функцией #elmtrans
*/
extern void eig_hess_reduction(double **A, size_t n, size_t low, size_t high, size_t *perm);

/**
  Трансформирующая матрица к верхней форме Хессенберга.

  Для квадратной вещественной матрицы \f$A\f$ порядка \f$n\f$ строит 
  трансформирующую матрицу \f$Q\f$,
  приводящую к верхней форме Хессенберга.
  На входе параметры \f$low\f$, \f$high\f$ --- из функции #eig_balance,
  \f$A\f$, \f$perm\f$ --- из #eig_hess
*/
extern void eig_hess_transform_matrix(double **A, size_t n, size_t low, size_t high, 
                               size_t *perm, double **Q);


/**
  Собственные числа и векторы матрицы Хессенберга

  Для матрицы Хессенберга \f$A\f$ находит собственные числа и, если \f$matq \ne 0\f$, -
  собственные векторы. Действительные части собственных чисел возвращаются
  в векторе \f$wr\f$, мнимые --- \f$wi\f$. Для вещественных собственных чисел
  (\f$wi[j]=0\f$) столбец \f$j\f$ содержит соответствующий собственный вектор.
  Для пары комплексно сопряженных собственных чисел (\f$wr[j]=wr[j+1]\f$,
  \f$wi[j]=-wi[j+1]\f$) \f$j\f\f$-й столбец матрицы \f$Q\f\f$ содержит действительную часть 
  \f$j\f$-го собственного вектора, а \f$(j+1)\f$-й - его мнимую часть. \f$(j+1)\f$-й
  собственный вектор комплексно сопряжен к нему.  В векторе \f$iter\f$ 
  возвращается число итераций, используемых для нахождения каждого собственного числа.

  Если \f$matq = 0\f$, то на место матрицы \f$Q\f$ ничего не записывается и можно
  задать \f$Q = NULL\f$.

  На выходе, если все прошло успешно, то \f$rc = 0\f$.
  В противном случае число итераций превысило 30
  и в \f$rc\f$ возвращается количество верно найденных собственных чисел.
*/
extern void eig_hess(double **A, size_t n, size_t low, size_t high,
         double *wr, double *wi, int matq, double **Q, size_t *iter, size_t *rc);


/**
  Обратное балансирование.

  По собственным векторам \f$Q\f$, найденным для сбалансированной матрицы \f$A\f$,
  находит собственные векторы исходной матрицы.
*/
extern void eig_balance_inverse(double **Q, size_t n, size_t low, size_t high, double *scal);


/**
  Нормирование собственных векторов.

  Нормировка собственных векторов по их чебышевой (Inf) норме.
*/
extern void eig_norm_Inf(double **Q, size_t n, double *wi);

/**
  Вычисление собственных векторов по методу обратной итерации.

  Вычисление собственных векторов матрицы Хессенберга по собственным числам.
  Автоматически вызывается функцией #eig_hess, если vec == 1
*/
extern void eig_vectors(double **A, size_t n, size_t low, size_t high, 
             double *wr, double *wi, double **Q);


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
/* 
  Далее идут функции по hqr алгоритму - старый вариант - менее мощные
  - собственные векторы не ищутся, только собственные числа.
*/

/*
  Матрица \f$A\f$ заменяется на сбалансированную матрицу с теми же собственными
  числами. Симметричная матрица уже сбалансирована и применение к ней этой
  функции не меняет этой матрицы. Параметр RADIX должен равняться основанию
  машинной арифметики.
*/

void eig_balance_old(double **a, size_t n);


/*
  Приведение матрицы к форме Хессенберга.
  Действительная несимметричная матрица приводится к форме Хессенберга
  с теми же собственными числами. Рекомендуется перед вызовом этой функции
  вызвать функцию #balanc. Элементы матрицы Хессенберга возвращаются
  в ячейках \f$a[i][j]\f$ где \f$i \le j + 1\f$. Остальные элементы равны нулю,
  хотя соответствующие элементы в матрице \f$A\f$ "случайны".
*/

void eig_hess_reduction_old(double **a, size_t n);
    

/*
  Функция находит все собственные числа матрицы Хессенберга \f$A\f$. 
  На входе в качестве \f$A\f$ нужно взять матрицу \f$A\f$, возвращаемую функцией #elmhes.
  Вещественные и мнимые части собственных чисел возвращаются в векторах
  \f$wr\f$ и \f$Wi\f$.
*/

void eig_hess_old(double **a, size_t n, double *wr, double *wi);

#endif
