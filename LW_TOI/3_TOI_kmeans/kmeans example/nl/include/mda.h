#ifndef __MDA_H
#define __MDA_H

#include "util.h"

/**
  \file
  Метод минимальной степени для переупорядочения симметричной разреженной матрицы.

  Метод минимальной степени используется на предварительном этапе
  алгоритма решения разреженной симметричной системы. Он находит переупорядочение строк
  и столбцов исходной симметричной положительно определенной матрицы, такое, что 
  разложение Холецкого полученной матрицы, как правило, имеет небольшое заполнение.

  Для решения системы уравнений \f$Ax=b\f$ с симметричной положительно определенной 
  разреженной матрицей \f$A\f$ следует:

    - с помощью функций #mda_init, #mda_convert, #mda_order найти переупорядочение 
      \f$P\f$ строк и столбцов матрицы \f$A\f$;
    - с помощью функции #sp_permute_sym переставить строки и столбцы в матрице \f$A\f$
      следующим образом: \f$PAP^{T}\f$;
    - с помощью функций #sp_chol_symb, #sp_chol_num найти разложение Холецкого
      матрицы \f$PAP^{T}\f$;
    - с помощью функции #nl_dvector_permute переставить элементы вектора \f$b\f$
      следующим образом: \f$Pb\f$;
    - с помощью функции #sp_chol_solve решить систему \f$PAP^{T}y=Pb\f$;
    - с помощью функции #nl_dvector_permute переставить элементы вектора \f$y\f$
      и, тем самым найти искомое решение \f$x=P^{T}y\f$.

  Также необходимо, используя, например, функции #mda_create, #nl_xvector_create, #nl_dvector_create,
  заранее выделить необходимую память и после окончания описанных действий освободить ее 
  с помощью функций #mda_free, #nl_xvector_free, #nl_dvector_free..


  \todo
   (Более или менее в порядке снижения приоритетности)
   - Исправить ошибки в #sp_order. См. xmda
   - Переписать #mda_order, чтобы она работала с форматом RR(U)O, а не RR(C)O
   - Ввиду предыдущего пункта убрать #mda_init и #mda_convert. Все предварительные
     вещи (их должно стать не так много) должны делаться в #mda_order
   - Исправить ошибки в #mda_chol_symb. См. xmda__ Эта функция и функция #mda_chol_num
     должны войтив модуль sparse
   - Исправить ошибки в #mda_chol_solve. Эта функция должна войти в модуль sparse
   После исправления этих ошибок к-во вызовов функций уменьшится:
    - #mda_order
    - #mda_chol_symb - функция будет называться по-другому
    - #mda_chol_num - функция будет называться по-другому
    - #mda_chol_solve - функция будет называться по-другому
*/

/**
  \example xmda.c
*/


/**
  Резервирование памяти для массивов, использующихся в MDA.

    - Вход:
      - \f$n\f$ - порядок симметричной матрицы
      - \f$nz\f$ - число ненулевых элементов над диагональю
    - Выход: 
      - \f$IA\f$ - массив длины \f$n+1\f$
      - \f$JA\f$ - массив длины \f$2nz\f$
      - \f$D\f$ - массив длины \f$n\f$ 
      - \f$P\f$ - массив длины \f$n\f$ 
      - \f$IP\f$ - массив длины \f$n\f$
      - \f$M\f$ - массив длины \f$n\f$ 
      - \f$L\f$ - массив длины \f$n\f$
*/ 
extern void mda_create(
	size_t n,
	size_t nz,
	size_t **IA,
	size_t **JA,
	size_t **D,
	size_t **P,
	size_t **IP,
	size_t **M,
	size_t **L);

/**
  Освобождение памяти, выделенной функцией #mda_create.
*/ 
extern void mda_free(
	size_t *IA,
	size_t *JA,
	size_t *D,
	size_t *P,
	size_t *IP,
	size_t *M,
	size_t *L);



/**	
  Предварительная инициализация для работы MDA.
  
    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$IA\f$ - массив из RR(C)O-представления портрета матрицы \f$A\f$
    - Выход:
      - \f$D\f$ - массив степеней узлов
      - \f$P\f$ - инициализированная (тождественная) перестановка узлов
      -	\f$IP\f$ - обратная перестановка (\f$IP[P[i]] = i\f$ и наоборот \f$P[IP[i]] = i\f$)
*/
extern void mda_init(
	size_t n,
	size_t *IA,
	size_t *D,
	size_t *P,
	size_t *IP);

/**	
  Преобразование симметричного представления в полное и инициализация для работы MDA.
  
  Преобразование симметричного RR(U)U представления матрицы \f$S\f$
  в полное представление RR(C)O, а также предварительная инициализация для
  работы MDA: вычисление степеней узлов \f$D\f$ и инициализация индексных массивов 
  \f$P\f$ и \f$IP\f$. При использовании этой функции #mda_init вызывать уже не следует.
    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$IS\f$, \f$JS\f$ - RR(U)U-представление портрета симметричной матрицы \f$A\f$
    - Выход:
      - \f$IA\f$, \f$JA\f$ - RR(C)O-представление портрета симметричной матрицы \f$A\f$
      - \f$D\f$ - массив степеней узлов
      - \f$P\f$ - инициализированная (тождественная) перестановка узлов
      -	\f$IP\f$ - обратная перестановка (\f$IP[P[i]] = i\f$ и наоборот \f$P[IP[i]] = i\f$)
*/
extern void mda_convert(
	size_t n,
	size_t *IS,
	size_t *JS,
	size_t *IA,
	size_t *JA,
	size_t *D,
	size_t *P,
	size_t *IP);

/*	
  Одна итерация MDA.
size_t mda_iterate(
	size_t h,
	size_t m,
	size_t n,
	size_t *IA,
	size_t *JA,
	size_t *M,
	size_t *L,
	size_t *D,
	size_t *P,
	size_t *IP);
*/

/**	
  Упорядочение методом MDA.

    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$IA\f$, \f$JA\f$ - RR(C)O-представление портрета симметричной матрицы \f$A\f$
      - \f$M\f$ - вспомогательный массив длины \f$n\f$
      - \f$L\f$ - вспомогательный массив длины \f$n\f$
      - \f$D\f$ - массив степеней узлов, возвращаемый функцией #mda_init или #mda_convert
      - \f$P\f$ - инициализированная перестановка узлов, возвращаемая функцией #mda_init или #mda_convert
      -	\f$IP\f$ - обратная перестановка, возвращаемая функцией #mda_init или #mda_convert
    - Выход:
      - функция возвращает число ненулевых элементов в верхней треугольной части разложения
        Холецкого
      - \f$D\f$ - массив степеней узлов
      - \f$P\f$ - найденная перестановка
      -	\f$IP\f$ - обратная перестановка
*/
extern size_t mda_order(
	size_t n,
	size_t *IA,
	size_t *JA,
	size_t *M,
	size_t *L,
	size_t *D,
	size_t *P,
	size_t *IP);

/**
  Символическое разложение Холецкого.
  Вроде здесь ошибки: см xspmda__.	
  Функция должна располагатся в sparse
    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$unz\f$ - 
      - \f$IS\f$, \f$JS\f$ - RR(U)O-представление портрета симметричной матрицы \f$A\f$
      - \f$M\f$ - вспомогательный массив длины \f$n\f$
      - \f$L\f$ - вспомогательный массив длины \f$n\f$
      - \f$D\f$ - массив степеней узлов, возвращаемый функцией #mda_order
      -	\f$IP\f$ - обратная перестановка, возвращаемая функцией #mda_order
    - Выход:
      - \f$IU\f$, \f$JU\f$ - RR(U)O-представление портрета разложения Холецкого матрицы \f$A\f$
*/
extern void mda_chol_symb(
	size_t n,
	size_t unz,
	size_t *IS,
	size_t *JS,
	size_t *IU,
	size_t *JU,
	size_t *M,
	size_t *L,
	size_t *D,
	size_t *IP);

/**	
  Численное разложение Холецкого.
  Функция должна располагатся в sparse
    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$IS\f$, \f$JS\f$, \f$SN\f$, \f$SD\f$ - RR(U)O-представление симметричной 
          матрицы \f$A\f$
      - \f$IU\f$, \f$JU\f$ - RR(U)O-представление портрета разложения Холецкого матрицы \f$A\f$,
          возвращаемое функцией #mda_chol_symb
      - \f$M\f$ - вспомогательный массив длины \f$n\f$
      - \f$L\f$ - вспомогательный массив длины \f$n\f$
      -	\f$P\f$ - перестановка, возвращаемая функцией #mda_order
    - Выход:
      - \f$UN\f$, \f$UD\f$ - значения элементов разложения Холецкого матрицы \f$A\f$ 
          над диагональю и на диагонали соответственно
*/
extern void mda_chol_num(
	size_t n,
	size_t *IS,
	size_t *JS,
	size_t *IU,
	size_t *JU,
	size_t *M,
	size_t *L,
	size_t *P,
	double *SN,
	double *SD,
	double *UN,
	double *UD);

/*	
  Решение системы на основе полученного разложения Холецкого.

  Решается система \f$Ax = b\f$ на основе полученного разложения Холецкого.
  Отличается от #sp_chol_solve дополнительной перестановкой найденного
  решения согласно перестановке \f$P\f$
  
    - Вход:
      - \f$n\f$ - порядок матрицы \f$A\f$
      - \f$IU\f$, \f$JU\f$, \f$UN\f$, \f$UD\f$ - RR(U)O-представление разложения Холецкого 
                                                 матрицы \f$A\f$, возвращаемое функциями
                                                 #mda_chol_symb и #mda_chol_num
      -	\f$P\f$ - перестановка, возвращаемая функцией #mda_order
      - \f$b\f$ - правая часть системы
    - Выход:
      - \f$x\f$ - найденное решение
*/
extern void mda_chol_solve(
	size_t n,
	size_t *IU,
	size_t *JU,
	size_t *P,
	double *UN,
	double *UD,
	double *b,
	double *x);

#endif
